Leetcode 3: Longest substring with repeated chars:

class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int n=s.size();
        if(n<=1)return n;
        int i=0;
        int maxi=INT_MIN;
        while(i<n){
            map<char,int> mpp;
            int j=i;
            int cnt=0;
            while(j<n){
                //cout<<i<<" "<<j<<" ";
                if(mpp.find(s[j])!=mpp.end()){
                    maxi = max(maxi,cnt);
                    i=mpp[s[j]]+1;
                    break;
                }
                else{
                    mpp[s[j]]=j;
                    cnt++;
                }
                j++;
            }
            if(j==n){
                maxi = max(maxi,cnt);
                break;
            }
        }
        //maxi = max(maxi,cnt);
        return maxi;
    }
};


leetcode 1004: Maximum consective ones III 

class Solution {
public:
    int longestOnes(vector<int>& nums, int k) {
        vector<int> a;
        int m=nums.size();
        int cnt=0;
        int ans =0;
        for(int i=0;i<m;i++){
            if(nums[i]==0){
                a.push_back(i);
                ans = max(ans,cnt);
                cnt=0;
            }
            else{
                cnt++;
            }
        }
        ans = max(ans,cnt);
        a.push_back(nums.size());
        if(k==0)return ans;
        int n=a.size()-1;
        if(n<=k)return m;
        ans = a[k-1]+1;
        int i=0;
        int j=k;
        
        while(j<n){
            int val = (a[j]-a[i])+(a[j+1]-1-a[j]);
            ans = max(ans,val);
            j=j+1;
            i=i+1;
        }
        return ans;
    }
};

leetcode 424: Longest repeating character replacement

class Solution {
public:
    int characterReplacement(string s, int k) {
        int n=s.size();
        int ans = 0,cnt=0;
        if(k==0){
            for(int i=1;i<n;i++){
                if(s[i-1]==s[i])cnt++;
                else{
                    ans = max(ans,cnt+1);
                    cnt=0;
                }
            }
            ans = max(ans,cnt+1);
            return ans;
        }
        int ind=0,i=0,ti=k,j=0;
        char val=s[0];
        while(j<n){
            int flag=0;
            i=j;
            cnt=0;
            while(i<n){
                if(s[i]==val){
                    cnt++;
                }
                else{
                    if(ti>0 && ti==k){
                        flag=1;
                        ind = i;
                        ti--;
                        cnt++;
                    }
                    else if(ti>0 && ti!=k){
                        ti--;
                        cnt++;
                    }
                    else if(ti<=0){
                        i=ind-1;
                        ans = max(ans,cnt);
                        val = s[ind];
                        cnt=0;
                        ti=k;
                    }
                }
                i++;
            }
            if(ti>0){
                cnt = min(n,cnt+ti);
            }
            ans = max(ans,cnt);
            if(flag==1)j=ind;
            else j=n;
        }
        
        ans = max(ans,cnt);
        return ans;
    }
};


leetcode 1248: count no of nice subarrays

class Solution {
public:
    int numberOfSubarrays(vector<int>& nums, int k) {
        vector<int> a;
        int n=nums.size();
        int cnt=0;
        for(auto it:nums){
            if(it%2==0){
                cnt++;
            }
            else{
                a.push_back(cnt);
                cnt=0;
            }
        }
        a.push_back(cnt);
        int ans=0;
        int i=0;
        int j=k-1;
        int m=a.size();
        while(j<m-1){
            ans += (a[i]*a[j+1]);
            ans += (a[i]+a[j+1])+1;
            i++;
            j++;
        }
        return ans;
    }
};

leetcode 1358: nof of substrings containing all 3 chars

class Solution {
public:
    int numberOfSubstrings(string s) {
        int n=s.size();
        int i=0;
        int j=0;
        vector<int> a(3,0);
        int ans=0;
        while(j<n){
            if(a[0]<=0 || a[1]<=0 || a[2]<=0){
                a[s[j]-'a']++;
            }
            while(a[0]>0 && a[1]>0 && a[2]>0){
                ans += (n-j);
                //cout<<ans<<" ";
                a[s[i]-'a']--;
                i++;
            }  
            j++;  
        }
        // while(true){
        //     if(a[0]<=0 || a[1]<=0 || a[2]<=0){
        //         break;
        //     }
        //     ans+=1;
        //     a[s[i]-'a']--;
        //     i++;
        // }
        return ans;
    }
};


leetcode 992: Subarrays with K different integers

class Solution {
public:
    int subarraysWithKDistinct(vector<int>& nums, int k) {
        int n=nums.size();
        int cnt1=0,cnt2=0,l=0,r=0,t=0;
        vector<int> arr(n+1,0);
        while(r<n){
            if(arr[nums[r]]==0){
                t++;
            }
            arr[nums[r]]+=1;
            if(t>k){
                while(l<=r){
                    if(arr[nums[l]]==1){
                        arr[nums[l]]=0;
                        t=t-1;
                        l++;
                        break;
                    }
                    arr[nums[l]]--;
                    l++;
                }
            }
            cnt1 += (r-l+1);
            r++;
        }
        r=0;
        l=0;
        t=0;
        vector<int> arr1(n+1,0);
        while(r<n){
            if(arr1[nums[r]]==0){
                t++;
            }
            arr1[nums[r]]+=1;
            if(t>k-1){
                while(l<=r){
                    if(arr1[nums[l]]==1){
                        arr1[nums[l]]=0;
                        t=t-1;
                        l++;
                        break;
                    }
                    arr1[nums[l]]--;
                    l++;
                }
            }
            cnt2 += (r-l+1);
            r++;
        }
        return cnt1-cnt2;
    }
};
