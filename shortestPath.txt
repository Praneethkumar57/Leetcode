// Undirected graph shortest path from node 0


vector<int> shortestpath(vector<vector<int>>& edges,int N,int M){
      vector<vector<int>> adj(N);
      for(auto it:edges){
        int u=it[0];
        int v=it[1];
        adj[u].push_back(v);
        adj[v].push_back(u);
      }
      vector<int> dist(N,INT_MAX);
      dist[0]=0;
      queue<int> q;
      q.push(0);
      while(!q.empty()){
        int node = q.front();
        int val = dist[node];
        q.pop();
        for(auto it:adj[node]){
          if(dist[it]==INT_MAX){
            dist[it]=min(dist[it],val+1);
            q.push(it);
          }
    
        }
      }
      for(int i=0;i<N;i++){
        if(dist[i]==INT_MAX){
          dist[i]=-1;
        }
        cout<<dist[i]<<" ";
      }
      return dist;
}


// leetcode 1091 shortest path in binary maze

class Solution {
public:
    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {
        int n=grid.size();
        
        vector<vector<int>> vis(n,vector<int>(n,0));
        queue<pair<int,int>> q;
        vector<vector<int>> level(n,vector<int>(n,INT_MAX));

        if(grid[0][0]==1)return -1;
        q.push({0,0});
        level[0][0]=1;
        vis[0][0]=1;
        while(!q.empty()){
            pair<int,int>ele= q.front();
            int i=ele.first;
            int j=ele.second;
            int lev=level[i][j];
            q.pop();
            if(i+1<n && j+1<n && grid[i+1][j+1]==0){
                if(lev+1 < level[i+1][j+1]){
                    level[i+1][j+1]=lev+1;
                    vis[i+1][j+1]=1;
                    q.push({i+1,j+1});
                }
            }
            if(i+1<n && grid[i+1][j]==0){
                if(lev+1 < level[i+1][j]){
                    level[i+1][j]=lev+1;
                    vis[i+1][j]=1;
                    q.push({i+1,j});
                }
            }
            if(j+1<n && grid[i][j+1]==0){
                if(lev+1 < level[i][j+1]){
                    level[i][j+1]=lev+1;
                    vis[i][j+1]=1;
                    q.push({i,j+1});
                }
            }
            if(i+1<n && j-1>=0 && grid[i+1][j-1]==0){
                if(lev+1 < level[i+1][j-1]){
                    level[i+1][j-1]=lev+1;
                    vis[i+1][j-1]=1;
                    q.push({i+1,j-1});
                }
            }
            if(j-1>=0 && grid[i][j-1]==0){
                if(lev+1 < level[i][j-1]){
                    level[i][j-1]=lev+1;
                    vis[i][j-1]=1;
                    q.push({i,j-1});
                }
            }
            if(i-1>=0 && j+1<n && grid[i-1][j+1]==0){
                if(lev+1 < level[i-1][j+1]){
                    level[i-1][j+1]=lev+1;
                    vis[i-1][j+1]=1;
                    q.push({i-1,j+1});
                }
            }
            if(i-1>=0  && grid[i-1][j]==0){
                if(lev+1 < level[i-1][j]){
                    level[i-1][j]=lev+1;
                    vis[i-1][j]=1;
                    q.push({i-1,j});
                }
            }
            if(i-1>=0 && j-1>=0 && grid[i-1][j-1]==0){
                if(lev+1 < level[i-1][j-1]){
                    level[i-1][j-1]=lev+1;
                    vis[i-1][j-1]=1;
                    q.push({i-1,j-1});
                }
            }
        }
        if(level[n-1][n-1]==INT_MAX)return -1;
        return level[n-1][n-1];
    }
};


// Dijkistra's algorithm and Network delay time (both are same with small change)

class Solution {
public:
    int networkDelayTime(vector<vector<int>>& times, int n, int k) {
        vector<int> dist(n+1,INT_MAX);
        vector<vector<pair<int,int>>> adj(n+1);
        for(auto it:times){
            int u=it[0];
            int v=it[1];
            int wt=it[2];
            adj[u].push_back({v,wt});
        }
        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>>pq;
        pq.push({k,0});
        dist[k]=0;
        while(!pq.empty()){
            pair<int,int> ele = pq.top();
            int node = ele.first;
            int wt=ele.second;
            pq.pop();

            if(wt>dist[node])continue;

            for(auto it:adj[node]){
                if(wt+it.second < dist[it.first]){
                    dist[it.first]=wt+it.second;
                    pq.push({it.first,dist[it.first]});
                }
            }
        }
        int maxi=0;
        for(int i=1;i<=n;i++){
            if(dist[i]==INT_MAX)return -1;
            maxi = max(maxi,dist[i]);
        }
        return maxi;
    }
};




// leetcode 1631 path with minimum effort


class Solution {
public:
    int minimumEffortPath(vector<vector<int>>& heights) {
        int n=heights.size();
        int m=heights[0].size();
        vector<vector<int>> dist(n,vector<int>(m,INT_MAX));
        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> pq;
        pq.push({0,{0,0}});
        dist[0][0]=0;

        while(!pq.empty()){
            pair<int,pair<int,int>> ele = pq.top();
            int val = ele.first;
            int i=ele.second.first;
            int j=ele.second.second;
            pq.pop();

            if(j+1<m){
                int newval = max(val,abs(heights[i][j]-heights[i][j+1]));
                if(newval<dist[i][j+1]){
                    dist[i][j+1]=newval;
                    pq.push({newval,{i,j+1}});
                }
            }
            if(i+1<n){
                int newval = max(val,abs(heights[i][j]-heights[i+1][j]));
                if(newval<dist[i+1][j]){
                    dist[i+1][j]=newval;
                    pq.push({newval,{i+1,j}});
                }
            }
            if(j-1>=0){
                int newval = max(val,abs(heights[i][j]-heights[i][j-1]));
                if(newval<dist[i][j-1]){
                    dist[i][j-1]=newval;
                    pq.push({newval,{i,j-1}});
                }
            }
            if(i-1>=0){
                int newval = max(val,abs(heights[i][j]-heights[i-1][j]));
                if(newval<dist[i-1][j]){
                    dist[i-1][j]=newval;
                    pq.push({newval,{i-1,j}});
                }
            }
        }
        return(dist[n-1][m-1]);
    }
};

// leetcode 787 cheapest flights within k stops (DP+ shortest path)
// Really a good question we need to use 2D price vector which stores lowest price to reach a node 'n' within (atmost) 'k' stops which acts as dp array and we need to find the cheapest flights to reach 'dst' within 'k' stops

class Solution {
public:
    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {
        vector<vector<int>> price(n,vector<int>(k+2,INT_MAX));
        vector<vector<pair<int,int>>> adj(n);
        for(auto it:flights){
            int u=it[0];
            int v=it[1];
            int p=it[2];
            adj[u].push_back({v,p});
        }
        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> pq;
        pq.push({0,{src,k+1}});
        price[src][k+1]=0;
        while(!pq.empty()){
            pair<int,pair<int,int>> ele = pq.top();
            int p=ele.first;
            int node=ele.second.first;
            int k_val = ele.second.second;
            pq.pop();
            if(p>price[node][k_val])continue;
            if(k_val<=0)continue;
            for(auto it:adj[node]){
                if(p+it.second < price[it.first][k_val-1] && k_val>0){
                    price[it.first][k_val-1]=p+it.second;
                    pq.push({price[it.first][k_val-1],{it.first,k_val-1}});
                }
                
            }
        }
        
        int mini=INT_MAX;
        for(int i=0;i<=k+1;i++){
            mini = min(mini,price[dst][i]);
        }
        if(mini==INT_MAX)return -1;
        return mini;
    }
};


// leetcode 778 swim in rising water

class Solution {
public:
    int swimInWater(vector<vector<int>>& grid) {
        int n=grid.size();
        vector<vector<int>> vis(n,vector<int>(n,0));
        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> pq;
        pq.push({grid[0][0],{0,0}});
        vis[0][0]=1;

        while(!pq.empty()){
            pair<int,pair<int,int>> ele = pq.top();
            int val = ele.first;
            int i=ele.second.first;
            int j=ele.second.second;
            pq.pop();

            if(i==n-1 && j==n-1)return val;

            if(i+1<n && !vis[i+1][j]){
                int newval = max(val,grid[i+1][j]);
                vis[i+1][j]=1;
                pq.push({newval,{i+1,j}});
            }
            if(j+1<n && !vis[i][j+1]){
                int newval = max(val,grid[i][j+1]);
                vis[i][j+1]=1;
                pq.push({newval,{i,j+1}});
            }
            if(i-1>=0 && !vis[i-1][j]){
                int newval = max(val,grid[i-1][j]);
                vis[i-1][j]=1;
                pq.push({newval,{i-1,j}});
            }
            if(j-1>=0 && !vis[i][j-1]){
                int newval = max(val,grid[i][j-1]);
                vis[i][j-1]=1;
                pq.push({newval,{i,j-1}});
            }
        }
        return 0;
    }
};


// leetcode 1334 Find the city with the smallest number of neighbours

class Solution {
public:
    int findTheCity(int n, vector<vector<int>>& edges, int distanceThreshold) {

        vector<vector<pair<int,int>>> adj(n);
        for(auto it:edges){
            int u=it[0];
            int v=it[1];
            int w=it[2];
            adj[u].push_back({v,w});
            adj[v].push_back({u,w});
        }
        vector<int> res;
        for(int i=0;i<n;i++){
            vector<int> d(n,INT_MAX);
            priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;
            pq.push({i,0});
            d[i]=0;
            while(!pq.empty()){
                pair<int,int> ele = pq.top();
                int node = ele.first;
                int dist = ele.second;
                pq.pop();

                for(auto it:adj[node]){
                    int newnode = it.first;
                    int newdist = it.second;

                    if(dist+newdist<d[newnode] && dist+newdist<=distanceThreshold){
                        pq.push({newnode,dist+newdist});
                        d[newnode]=dist+newdist;
                    }
                }
            }
            int cnt=0;
            for(auto j:d){
                if(j!=INT_MAX)cnt++;
            }
            res.push_back(cnt-1);
        }
        int mini=INT_MAX;
        int ind = 0;
        for(int i=0;i<n;i++){
            if(res[i]<=mini){
                mini = res[i];
                ind = i;
            }
        }
        return ind;
    }
};


// leetcode 1514 path with maximum probability

class Solution {
public:
    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start_node, int end_node) {
        vector<vector<pair<int,double>>> adj(n);
        for(int i=0;i<edges.size();i++){
            int u=edges[i][0];
            int v=edges[i][1];
            double pb = succProb[i];
            adj[u].push_back({v,pb});
            adj[v].push_back({u,pb});
        }
        vector<double> prob(n,0);

        priority_queue<pair<double,int>> pq;
        pq.push({1.0,start_node});
        prob[start_node]=1;
        while(!pq.empty()){
            pair<double,int> ele = pq.top();
            int node = ele.second;
            double p = ele.first;
            pq.pop();

            if(node==end_node){
                return p;
            }

            for(auto it:adj[node]){
                int newnode = it.first;
                double newp = it.second;

                if((p*newp)>prob[newnode]){
                    prob[newnode]=p*newp;
                    pq.push({prob[newnode],newnode});
                }
            }
        }
        return prob[end_node];
    }
};


// leetcode 1368 minimum cost to make at least one valid path in a grid


class Solution {
public:
    int minCost(vector<vector<int>>& grid) {
        int n= grid.size();
        int m=grid[0].size();
        vector<vector<int>> dist(n,vector<int>(m,INT_MAX));
        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> pq;
        pq.push({0,{0,0}});
        dist[0][0]=0;
        while(!pq.empty()){
            pair<int,pair<int,int>> ele = pq.top();
            int c = ele.first;
            int i= ele.second.first;
            int j=ele.second.second;
            pq.pop();

            if(i==n-1 && j==m-1)return c;

            if(grid[i][j]==1 && j+1<m && c<dist[i][j+1]){
                dist[i][j+1]=c;
                pq.push({dist[i][j+1],{i,j+1}});
            }
            else if(grid[i][j]!=1 && j+1<m && c+1<dist[i][j+1]){
                dist[i][j+1]=c+1;
                pq.push({dist[i][j+1],{i,j+1}});
            }

            if(grid[i][j]==2 && j-1>=0 && c<dist[i][j-1]){
                dist[i][j-1]=c;
                pq.push({dist[i][j-1],{i,j-1}});
            }
            else if(grid[i][j]!=2 && j-1>=0 && c+1<dist[i][j-1]){
                dist[i][j-1]=c+1;
                pq.push({dist[i][j-1],{i,j-1}});
            }

            if(grid[i][j]==3 && i+1<n && c<dist[i+1][j]){
                dist[i+1][j]=c;
                pq.push({dist[i+1][j],{i+1,j}});
            }
            else if(grid[i][j]!=3 && i+1<n && c+1<dist[i+1][j]){
                dist[i+1][j]=c+1;
                pq.push({dist[i+1][j],{i+1,j}});
            }

            if(grid[i][j]==4 && i-1>=0 && c<dist[i-1][j]){
                dist[i-1][j]=c;
                pq.push({dist[i-1][j],{i-1,j}});
            }
            else if(grid[i][j]!=4 && i-1>=0 && c+1<dist[i-1][j]){
                dist[i-1][j]=c+1;
                pq.push({dist[i-1][j],{i-1,j}});
            }
        }
        return dist[n-1][m-1];
    }
};


// leetcode 3341 Find minimum time to reach last room 1

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n=moveTime.size();
        int m=moveTime[0].size();
        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> pq;
        vector<vector<int>> time(n,vector<int>(m,INT_MAX));
        pq.push({0,{0,0}});
        time[0][0]=0;

        while(!pq.empty()){
            pair<int,pair<int,int>> ele = pq.top();
            int t = ele.first;
            int i = ele.second.first;
            int j = ele.second.second;
            pq.pop();

            if(i==n-1 && j==m-1)return t;

            if(i+1<n && t>=moveTime[i+1][j] && t+1<time[i+1][j]){
                time[i+1][j]=t+1;
                pq.push({time[i+1][j],{i+1,j}});
            }
            else if(i+1<n && t<moveTime[i+1][j]){
                int newtime = (moveTime[i+1][j]-t)+1;
                if(newtime+t<time[i+1][j]){
                    time[i+1][j]=newtime+t;
                    pq.push({time[i+1][j],{i+1,j}});
                }
            }

            if(j+1<m && t>=moveTime[i][j+1] && t+1<time[i][j+1]){
                time[i][j+1]=t+1;
                pq.push({time[i][j+1],{i,j+1}});
            }
            else if(j+1<m && t<moveTime[i][j+1]){
                int newtime = (moveTime[i][j+1]-t)+1;
                if(newtime+t<time[i][j+1]){
                    time[i][j+1]=newtime+t;
                    pq.push({time[i][j+1],{i,j+1}});
                }
            }

            if(i-1>=0 && t>=moveTime[i-1][j] && t+1<time[i-1][j]){
                time[i-1][j]=t+1;
                pq.push({time[i-1][j],{i-1,j}});
            }
            else if(i-1>=0 && t<moveTime[i-1][j]){
                int newtime = (moveTime[i-1][j]-t)+1;
                if(newtime+t<time[i-1][j]){
                    time[i-1][j]=newtime+t;
                    pq.push({time[i-1][j],{i-1,j}});
                }
            }

            if(j-1>=0 && t>=moveTime[i][j-1] && t+1<time[i][j-1]){
                time[i][j-1]=t+1;
                pq.push({time[i][j-1],{i,j-1}});
            }
            else if(j-1>=0 && t<moveTime[i][j-1]){
                int newtime = moveTime[i][j-1]-t+1;
                if(newtime+t<time[i][j-1]){
                    time[i][j-1]=newtime+t;
                    pq.push({time[i][j-1],{i,j-1}});
                }
            }
        }
        return time[n-1][m-1];
    }
};
