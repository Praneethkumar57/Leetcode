// Undirected graph shortest path from node 0


vector<int> shortestpath(vector<vector<int>>& edges,int N,int M){
      vector<vector<int>> adj(N);
      for(auto it:edges){
        int u=it[0];
        int v=it[1];
        adj[u].push_back(v);
        adj[v].push_back(u);
      }
      vector<int> dist(N,INT_MAX);
      dist[0]=0;
      queue<int> q;
      q.push(0);
      while(!q.empty()){
        int node = q.front();
        int val = dist[node];
        q.pop();
        for(auto it:adj[node]){
          if(dist[it]==INT_MAX){
            dist[it]=min(dist[it],val+1);
            q.push(it);
          }
    
        }
      }
      for(int i=0;i<N;i++){
        if(dist[i]==INT_MAX){
          dist[i]=-1;
        }
        cout<<dist[i]<<" ";
      }
      return dist;
}


// leetcode 1091 shortest path in binary maze

class Solution {
public:
    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {
        int n=grid.size();
        
        vector<vector<int>> vis(n,vector<int>(n,0));
        queue<pair<int,int>> q;
        vector<vector<int>> level(n,vector<int>(n,INT_MAX));

        if(grid[0][0]==1)return -1;
        q.push({0,0});
        level[0][0]=1;
        vis[0][0]=1;
        while(!q.empty()){
            pair<int,int>ele= q.front();
            int i=ele.first;
            int j=ele.second;
            int lev=level[i][j];
            q.pop();
            if(i+1<n && j+1<n && grid[i+1][j+1]==0){
                if(lev+1 < level[i+1][j+1]){
                    level[i+1][j+1]=lev+1;
                    vis[i+1][j+1]=1;
                    q.push({i+1,j+1});
                }
            }
            if(i+1<n && grid[i+1][j]==0){
                if(lev+1 < level[i+1][j]){
                    level[i+1][j]=lev+1;
                    vis[i+1][j]=1;
                    q.push({i+1,j});
                }
            }
            if(j+1<n && grid[i][j+1]==0){
                if(lev+1 < level[i][j+1]){
                    level[i][j+1]=lev+1;
                    vis[i][j+1]=1;
                    q.push({i,j+1});
                }
            }
            if(i+1<n && j-1>=0 && grid[i+1][j-1]==0){
                if(lev+1 < level[i+1][j-1]){
                    level[i+1][j-1]=lev+1;
                    vis[i+1][j-1]=1;
                    q.push({i+1,j-1});
                }
            }
            if(j-1>=0 && grid[i][j-1]==0){
                if(lev+1 < level[i][j-1]){
                    level[i][j-1]=lev+1;
                    vis[i][j-1]=1;
                    q.push({i,j-1});
                }
            }
            if(i-1>=0 && j+1<n && grid[i-1][j+1]==0){
                if(lev+1 < level[i-1][j+1]){
                    level[i-1][j+1]=lev+1;
                    vis[i-1][j+1]=1;
                    q.push({i-1,j+1});
                }
            }
            if(i-1>=0  && grid[i-1][j]==0){
                if(lev+1 < level[i-1][j]){
                    level[i-1][j]=lev+1;
                    vis[i-1][j]=1;
                    q.push({i-1,j});
                }
            }
            if(i-1>=0 && j-1>=0 && grid[i-1][j-1]==0){
                if(lev+1 < level[i-1][j-1]){
                    level[i-1][j-1]=lev+1;
                    vis[i-1][j-1]=1;
                    q.push({i-1,j-1});
                }
            }
        }
        if(level[n-1][n-1]==INT_MAX)return -1;
        return level[n-1][n-1];
    }
};


// Dijkistra's algorithm and Network delay time (both are same with small change)

class Solution {
public:
    int networkDelayTime(vector<vector<int>>& times, int n, int k) {
        vector<int> dist(n+1,INT_MAX);
        vector<vector<pair<int,int>>> adj(n+1);
        for(auto it:times){
            int u=it[0];
            int v=it[1];
            int wt=it[2];
            adj[u].push_back({v,wt});
        }
        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>>pq;
        pq.push({k,0});
        dist[k]=0;
        while(!pq.empty()){
            pair<int,int> ele = pq.top();
            int node = ele.first;
            int wt=ele.second;
            pq.pop();

            if(wt>dist[node])continue;

            for(auto it:adj[node]){
                if(wt+it.second < dist[it.first]){
                    dist[it.first]=wt+it.second;
                    pq.push({it.first,dist[it.first]});
                }
            }
        }
        int maxi=0;
        for(int i=1;i<=n;i++){
            if(dist[i]==INT_MAX)return -1;
            maxi = max(maxi,dist[i]);
        }
        return maxi;
    }
};
