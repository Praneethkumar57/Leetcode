// Undirected graph shortest path from node 0


vector<int> shortestpath(vector<vector<int>>& edges,int N,int M){
      vector<vector<int>> adj(N);
      for(auto it:edges){
        int u=it[0];
        int v=it[1];
        adj[u].push_back(v);
        adj[v].push_back(u);
      }
      vector<int> dist(N,INT_MAX);
      dist[0]=0;
      queue<int> q;
      q.push(0);
      while(!q.empty()){
        int node = q.front();
        int val = dist[node];
        q.pop();
        for(auto it:adj[node]){
          if(dist[it]==INT_MAX){
            dist[it]=min(dist[it],val+1);
            q.push(it);
          }
    
        }
      }
      for(int i=0;i<N;i++){
        if(dist[i]==INT_MAX){
          dist[i]=-1;
        }
        cout<<dist[i]<<" ";
      }
      return dist;
}


// leetcode 1091 shortest path in binary maze

class Solution {
public:
    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {
        int n=grid.size();
        
        vector<vector<int>> vis(n,vector<int>(n,0));
        queue<pair<int,int>> q;
        vector<vector<int>> level(n,vector<int>(n,INT_MAX));

        if(grid[0][0]==1)return -1;
        q.push({0,0});
        level[0][0]=1;
        vis[0][0]=1;
        while(!q.empty()){
            pair<int,int>ele= q.front();
            int i=ele.first;
            int j=ele.second;
            int lev=level[i][j];
            q.pop();
            if(i+1<n && j+1<n && grid[i+1][j+1]==0){
                if(lev+1 < level[i+1][j+1]){
                    level[i+1][j+1]=lev+1;
                    vis[i+1][j+1]=1;
                    q.push({i+1,j+1});
                }
            }
            if(i+1<n && grid[i+1][j]==0){
                if(lev+1 < level[i+1][j]){
                    level[i+1][j]=lev+1;
                    vis[i+1][j]=1;
                    q.push({i+1,j});
                }
            }
            if(j+1<n && grid[i][j+1]==0){
                if(lev+1 < level[i][j+1]){
                    level[i][j+1]=lev+1;
                    vis[i][j+1]=1;
                    q.push({i,j+1});
                }
            }
            if(i+1<n && j-1>=0 && grid[i+1][j-1]==0){
                if(lev+1 < level[i+1][j-1]){
                    level[i+1][j-1]=lev+1;
                    vis[i+1][j-1]=1;
                    q.push({i+1,j-1});
                }
            }
            if(j-1>=0 && grid[i][j-1]==0){
                if(lev+1 < level[i][j-1]){
                    level[i][j-1]=lev+1;
                    vis[i][j-1]=1;
                    q.push({i,j-1});
                }
            }
            if(i-1>=0 && j+1<n && grid[i-1][j+1]==0){
                if(lev+1 < level[i-1][j+1]){
                    level[i-1][j+1]=lev+1;
                    vis[i-1][j+1]=1;
                    q.push({i-1,j+1});
                }
            }
            if(i-1>=0  && grid[i-1][j]==0){
                if(lev+1 < level[i-1][j]){
                    level[i-1][j]=lev+1;
                    vis[i-1][j]=1;
                    q.push({i-1,j});
                }
            }
            if(i-1>=0 && j-1>=0 && grid[i-1][j-1]==0){
                if(lev+1 < level[i-1][j-1]){
                    level[i-1][j-1]=lev+1;
                    vis[i-1][j-1]=1;
                    q.push({i-1,j-1});
                }
            }
        }
        if(level[n-1][n-1]==INT_MAX)return -1;
        return level[n-1][n-1];
    }
};


// Dijkistra's algorithm and Network delay time (both are same with small change)

class Solution {
public:
    int networkDelayTime(vector<vector<int>>& times, int n, int k) {
        vector<int> dist(n+1,INT_MAX);
        vector<vector<pair<int,int>>> adj(n+1);
        for(auto it:times){
            int u=it[0];
            int v=it[1];
            int wt=it[2];
            adj[u].push_back({v,wt});
        }
        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>>pq;
        pq.push({k,0});
        dist[k]=0;
        while(!pq.empty()){
            pair<int,int> ele = pq.top();
            int node = ele.first;
            int wt=ele.second;
            pq.pop();

            if(wt>dist[node])continue;

            for(auto it:adj[node]){
                if(wt+it.second < dist[it.first]){
                    dist[it.first]=wt+it.second;
                    pq.push({it.first,dist[it.first]});
                }
            }
        }
        int maxi=0;
        for(int i=1;i<=n;i++){
            if(dist[i]==INT_MAX)return -1;
            maxi = max(maxi,dist[i]);
        }
        return maxi;
    }
};




// leetcode 1631 path with minimum effort


class Solution {
public:
    int minimumEffortPath(vector<vector<int>>& heights) {
        int n=heights.size();
        int m=heights[0].size();
        vector<vector<int>> dist(n,vector<int>(m,INT_MAX));
        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> pq;
        pq.push({0,{0,0}});
        dist[0][0]=0;

        while(!pq.empty()){
            pair<int,pair<int,int>> ele = pq.top();
            int val = ele.first;
            int i=ele.second.first;
            int j=ele.second.second;
            pq.pop();

            if(j+1<m){
                int newval = max(val,abs(heights[i][j]-heights[i][j+1]));
                if(newval<dist[i][j+1]){
                    dist[i][j+1]=newval;
                    pq.push({newval,{i,j+1}});
                }
            }
            if(i+1<n){
                int newval = max(val,abs(heights[i][j]-heights[i+1][j]));
                if(newval<dist[i+1][j]){
                    dist[i+1][j]=newval;
                    pq.push({newval,{i+1,j}});
                }
            }
            if(j-1>=0){
                int newval = max(val,abs(heights[i][j]-heights[i][j-1]));
                if(newval<dist[i][j-1]){
                    dist[i][j-1]=newval;
                    pq.push({newval,{i,j-1}});
                }
            }
            if(i-1>=0){
                int newval = max(val,abs(heights[i][j]-heights[i-1][j]));
                if(newval<dist[i-1][j]){
                    dist[i-1][j]=newval;
                    pq.push({newval,{i-1,j}});
                }
            }
        }
        return(dist[n-1][m-1]);
    }
};

// leetcode 787 cheapest flights within k stops
class Solution {
public:
    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {
        vector<int> price(n,INT_MAX);
        vector<vector<pair<int,int>>> adj(n);
        for(auto it:flights){
            int u=it[0];
            int v=it[1];
            int p=it[2];
            adj[u].push_back({v,p});
        }
        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> pq;
        pq.push({0,{src,k}});
        while(!pq.empty()){
            pair<int,pair<int,int>> ele = pq.top();
            int p=ele.first;
            int node=ele.second.first;
            int k_val = ele.second.second;
            pq.pop();
            //if(p>price[node])continue;
            if(k_val<0)continue;
            for(auto it:adj[node]){
                if(p+it.second < price[it.first] && k_val>=0){
                    price[it.first]=p+it.second;
                    pq.push({price[it.first],{it.first,k_val-1}});
                }
            }
        }
        if(price[dst]==INT_MAX)return -1;
        return price[dst];
    }
};
